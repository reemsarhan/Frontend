JavaScript: is a high-level, interpreted, object-oriented programming language used mainly to create interactive web pages. It runs in the browser and makes websites dynamic (respond to user actions).

1. Primitive Data Types
These hold single values and are immutable (can’t be changed).
Type	Description	Example
String	Text	"Hello" or 'Hi'
Number	Integers and floats	42, 3.14
Boolean	True or false	true, false
Null	Intentional empty value	null
Undefined	Variable declared but not assigned	let x; // x is undefined
BigInt	Very large integers	12345678901234567890n
Symbol	Unique, immutable value (used as object keys)	Symbol("id")

2. Non-Primitive (Reference) Data Types
These can hold collections of values or more complex data.
Type	Description	Example
Object	Key-value pairs	{ name: "Reem", age: 25 }
Array	Ordered list	[1, 2, 3, 4]
Function	Callable object	function greet() {}
Date, RegExp, etc.	Built-in objects	new Date(), /abc/


         var	   let	  const
    	Function	Block	   Block

Hoisting is JavaScript's behavior of moving declarations to the top of their scope before the code is executed.

In other words, variables and functions are "hoisted" (lifted) to the top of their scope (global or function), even if they’re written later in the code.

A callback is simply a function passed as an argument to another function, which gets called later, usually after a task is completed.



1. Function Declaration
This is when you declare a function using the function keyword with a name.

 2. Function Expression
This is when you assign a function to a variable.


add JavaScript to HTML:
 1. Inline JavaScript
You can add JS code directly inside an HTML element’s attribute, usually onclick, onmouseover, etc.
 2. Internal JavaScript
Write JavaScript inside a <script> tag within your HTML file.
3. External JavaScript
Link to a separate .js file using the <script src="file.js"> tag.


A closure is when a function remembers and accesses variables from its outer (lexical) scope, even after that outer function has finished executing.
```
function outer() {
  let count = 0;

  return function inner() {
    count++;
    console.log("Count is:", count);
  };
}

const counter = outer(); // outer runs and returns inner
counter(); // Count is: 1
counter(); // Count is: 2
counter(); // Count is: 3
```


To access HTML elements in JavaScript, you use DOM (Document Object Model) methods:
 1. getElementById()
 2. getElementsByClassName()
 3. getElementsByTagName()
 4. querySelector() //matching css selector
 5. querySelectorAll()

 Event Bubbling
Event bubbling is the default behavior in most cases. When an event is triggered on an element, it first triggers on the innermost element (the target), and then bubbles up to the parent elements in the DOM hierarchy.

Order of propagation: Target element → Parent → Grandparent → ... → Root (<html>)



  Event Capturing
Event capturing (or trickling) is the opposite of event bubbling. Instead of starting from the target element, it starts from the root of the DOM and travels down to the target element.

Order of propagation: Root (<html>) → Grandparent → Parent → Target element

To use event capturing, you need to explicitly set the third argument in addEventListener() to true.


Event delegation is a technique in JavaScript where you attach a single event listener to a parent element instead of adding multiple listeners to individual child elements.
The event listener on the parent element listens for events on its child elements through event bubbling.

 
Strict mode is a way to opt in to a restricted version of JavaScript, which helps catch common coding mistakes and prevents certain behaviors that can lead to bugs or security vulnerabilities. 
When JavaScript is in strict mode, it behaves more strictly than the normal mode.

call(), apply(), and bind() are methods of functions that allow you to explicitly set the value of  "this"  and invoke or create a new function with that this value.
 1. call()
Invokes the function immediately
You pass arguments one by one
2. apply()
Same as call(), but arguments are passed as an array
 3. bind()
Does NOT invoke the function immediately
Returns a new function with this bound permanently

filter, map, and forEach — the array iteration methods in JavaScript.

 1-forEach()
Loops through each item in the array.
Does not return anything (just runs a function for each item).
 2-map()
Loops through the array and returns a new array with modified values.
 3-filter()
Loops through and returns a new array with only items that pass the condition.



   ✅ Using Promises:
fetch('https://api.example.com/data')
  .then(res => res.json())
  .then(data => console.log(data))
  .catch(err => console.log(err));


✅ Using async/await:
async function getData() {
  try {
    const res = await fetch('https://api.example.com/data');
    const data = await res.json();
    console.log(data);
  } catch (err) {
    console.log(err);
  }
}
getData();


